#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S4,     IR,             sensorI2CCustom)
#pragma config(Motor,  motorB,          encoderLeft,   tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          encoderRight,  tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     turntable,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     arm,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     driveLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     driveRight,    tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_5,    sliderServo,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_6,    irServo,              tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
* autonomous_3.c
* This file is part of Autonomous
*
* Copyright (C) 2012 - EMC Squirrled
*
* Autonomous is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* Autonomous is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Autonomous; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor,
* Boston, MA  02110-1301  USA
*/

/* ===== INCLUDES ===== */

#include <JoystickDriver.c>
#include "../includes/rdpartyrobotcdr-3.1/drivers/hitechnic-irseeker-v2.h"

/* ===== DEFINES ===== */

#define vOffLeft() vOnLeft(0)
#define vOffRight() vOnRight(0)

/* ===== FUNCTIONS ===== */

void vInitializeRobot(void);
void vOnLeft(short iPower);
void vOnRight(short iPower);
bool bAtBeacon(void);

/* ===== GLOBALS ===== */

const int IR_POS_UP = 255;
const int IR_POS_DOWN = 10;

const int CONT_FWD = 255;
const int CONT_OFF = 127;
const int CONT_BWD = 0;

const int DRIVE_SPEED = 40;

const int MAX_SECS = 5 * 1000;

/* ===== CODE ===== */

task main() {
	vInitializeRobot();
	waitForStart();

	servo[irServo] = IR_POS_UP;

	vOnLeft(-1 * DRIVE_SPEED);
	vOnRight(-1 * DRIVE_SPEED);

	ClearTimer(T1);
	while((time1[T1] < MAX_SECS) && (!bAtBeacon())) {
		/* Do nothing */
	}

	vOffLeft();
	vOffRight();

	if(bAtBeacon()) {
		servo[sliderServo] = CONT_FWD;
		wait1Msec(2500);
		servo[sliderServo] = CONT_OFF;

		vOnLeft(DRIVE_SPEED);
		vOnRight(DRIVE_SPEED);
		wait1Msec(500);
		vOffLeft();
		vOffRight();

		servo[sliderServo] = CONT_BWD;
		wait1Msec(2500);
		servo[sliderServo] = CONT_OFF;
	}
}

void vInitializeRobot(void) {
	disableDiagnosticsDisplay();
	vOffLeft();
	vOffRight();
	servo[irServo] = IR_POS_DOWN;
	servo[sliderServo] = CONT_OFF;
}

bool bAtBeacon(void) {
	int zones[5];
	HTIRS2readAllACStrength(IR, zones[0], zones[1], zones[2], zones[3], zones[4]);
	clearDebugStream();
	for(int i = 0; i < 5; i++) {
		writeDebugStreamLine("zone %d:\t%d", i, zones[i]);
	}
	return ((zones[1] > 50) && (zones[2] > 50) && (abs(zones[1] - zones[2]) < 10));
}

void vOnLeft(short iPower) {
	motor[driveLeft] = -1 * iPower;
	return;
}

void vOnRight(short iPower) {
	motor[driveRight] = iPower;
	return;
}
