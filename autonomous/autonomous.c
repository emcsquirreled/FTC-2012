#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S4,     IR,             sensorI2CCustom)
#pragma config(Motor,  motorB,          encoderLeft,   tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          encoderRight,  tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     turntable,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     arm,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     driveLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     driveRight,    tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_5,    sliderServo,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_6,    irServo,              tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
* autonomous.c
* This file is part of Autonomous
*
* Copyright (C) 2012 - EMC Squirrled
*
* Autonomous is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* Autonomous is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Autonomous; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor,
* Boston, MA  02110-1301  USA
*/

/* ===== INCLUDES ===== */

#include <JoystickDriver.c>
#include "../includes/rdpartyrobotcdr-3.1/drivers/hitechnic-irseeker-v2.h"

/* ===== DEFINES ===== */

/* vOffLeft() and vOffRight() are simple macros for the full functions */
#define vOffLeft() vOnLeft(0)
#define vOffRight() vOnRight(0)

/* ===== FUNCTIONS ===== */

void vInitializeRobot(void);
void vOnLeft(short iPower);
void vOnRight(short iPower);
bool bAtBeacon(void);

/* ===== GLOBALS ===== */

/* Infrared beacon arm servo values */
const int IR_POS_UP = 255;
const int IR_POS_DOWN = 10;

/* Continuous rotation servo values */
const int CONT_FWD = 255;
const int CONT_OFF = 127;
const int CONT_BWD = 0;

/* Main drive speed */
const int DRIVE_SPEED = 40;

/* Milliseconds before we give up on the beacon */
const int MAX_SECS = 5 * 1000;

/* Have we near the beacon? */
bool inRange = false;

/* ===== CODE ===== */

/* Main Task */
task main() {
	bool isAtBeacon;

	/* Set up autonomous */
	vInitializeRobot();
	waitForStart();

	/* Put motors and servos into their initial positions */
	servo[irServo] = IR_POS_UP;

	vOnLeft(DRIVE_SPEED);
	vOnRight(DRIVE_SPEED);

	/* Drive until we either find or miss the beacon */
	ClearTimer(T1);
	do {
		isAtBeacon = bAtBeacon();
	} while((time1[T1] < MAX_SECS) && (!isAtBeacon));

	/* Stop the robot */
	vOffLeft();
	vOffRight();

	if(time1[T1] > 4000) {
		wait1Msec(100);

		vOnLeft(-40);
		vOnRight(-40);
		wait1Msec(500);
		vOffLeft();
		vOffRight();

		wait1Msec(100);

		isAtBeacon = false;
		inRange = false;
		vOnLeft(DRIVE_SPEED / 2);
		vOnRight(DRIVE_SPEED / 2);
		do {
			isAtBeacon = bAtBeacon();
		} while(!isAtBeacon);

		vOffLeft();
		vOffRight();
	}




	/* If we found the beacon, score the ring */
	if(isAtBeacon){
		/* Extend the arm, placing the ring on the peg */
		servo[sliderServo] = CONT_FWD;
		wait1Msec(2500);
		servo[sliderServo] = CONT_OFF;

		/* Drive away */
		vOnLeft(DRIVE_SPEED);
		vOnRight(DRIVE_SPEED);
		wait1Msec(500);
		vOffLeft();
		vOffRight();

		/* Retract the arm */
		servo[sliderServo] = CONT_BWD;
		wait1Msec(2500);
		servo[sliderServo] = CONT_OFF;
	}
}

/* Initializes the robot */
void vInitializeRobot(void) {
	/* Clean the screen so we can use it for debugging */
	disableDiagnosticsDisplay();

	/* Put all motors and servos in their starting positions */
	vOffLeft();
	vOffRight();
	servo[irServo] = IR_POS_DOWN;
	servo[sliderServo] = CONT_OFF;
}

/* Checks to see if we are next to the beacon */
bool bAtBeacon(void) {
	/* Declare variables */
	int zones[5];
	int average = 0;
	bool atBeacon = false;

	/* Read the infrared seeker into an array */
	HTIRS2readAllACStrength(IR, zones[0], zones[1], zones[2], zones[3], zones[4]);

	/* Find the average infrared noise level */
	for(int i = 0; i < 5; i++) average += zones[i];
	average /= 5;

	/* If the critical zones are stronger than the noise, we are in range */
	if(((zones[1] - average) > 10) && ((zones[2] - average) > 10)) inRange = true;

	/* When we are in range and the critical zones are nearly equal (or we have overshot) we are at the beacon */
	if(inRange && ((zones[1] - zones[2]) > 0)) atBeacon = true;

	return atBeacon;
}

/* Turn the left motor on to the proper power */
void vOnLeft(short iPower) {
	motor[driveLeft] = -1 * iPower;
	return;
}

/* Turn the right motor on to the proper power */
void vOnRight(short iPower) {
	motor[driveRight] = iPower;
	return;
}
